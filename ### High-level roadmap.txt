### High-level roadmap

- **Phase 1 (MVP): Live tracking + destination + seat tier**
- **Phase 2: Reliability, safety, and usability upgrades**
- **Phase 3: Data, automation, and scalability**

Below is what each phase should include for backend and frontend.

### Phase 1 — MVP

- **Backend (recommended: pick one)**
  - **Option A: Firebase (faster to ship)**
    - Auth: Email/password + Role claims (`student`, `driver`, `admin`)
    - Realtime DB or Firestore: `buses`, `locations`, `statuses`
    - Security rules: role-based read/write
    - Cloud Functions: sanitize writes, audit logs, geofencing utility
    - Realtime updates: native RTDB listeners or Firestore snapshots
  - **Option B: Node.js + MongoDB (more control)**
    - Auth: JWT + Role-based access control
    - WS/SSE for live updates
    - REST APIs:
      - `POST /auth/login` (driver/admin)
      - `GET /buses` (list with latest status)
      - `GET /buses/:id`
      - `POST /buses/:id/location` (driver)
      - `POST /buses/:id/status` (driver: destination, seat tier)
      - `GET /live` (SSE for live map feed)
    - Collections/Tables:
      - `buses` {id, regNo, routeName, capacity}
      - `busStatus` {busId, destination, seatTier, updatedAt}
      - `busLocation` {busId, lat, lng, speed, heading, updatedAt}
      - `users` {id, email, role, driverBusId?}
    - Rate limiting + validation

- **Frontend**
  - **Student dashboard**
    - Live map with bus markers and info cards (destination, tier: Empty/Few/Full)
    - Filter by destination (Campus 25/6/15)
    - Basic “last updated” timestamp
  - **Driver dashboard**
    - Sign-in
    - Set destination (predefined list)
    - Set seat availability (Empty/Few/Full)
    - Share location (manual send button + optional background in browser/app)
  - **Admin (basic)**
    - Create/edit buses
    - Assign drivers to buses
    - View live list of buses with health (last ping)

- **Non-functional (MVP)**
  - Basic audit (who changed what, when)
  - Input validation and anti-spam (location update min interval)
  - Simple error handling and empty states

### Phase 2 — Reliability, safety, usability

- **Backend**
  - Health checks: mark bus “stale” if no update in X minutes
  - Geofencing utilities (campus polygons; compute ETA to campus)
  - Aggregated live feed endpoint (optimized payload for map)
  - Soft-delete and versioning for bus data
  - Observability: request logs, metrics (update frequency, stale counts)
  - Admin APIs:
    - `POST /buses` CRUD
    - `POST /drivers/assign`
  - Notification plumbing (topic registration per destination)
  - Role-scoped security hardening and least-privilege policies

- **Frontend**
  - **Student**
    - Destination quick filters and “nearest bus” highlight
    - “Stale” badge when no recent updates
    - Performance: clustered markers, incremental rendering
  - **Driver**
    - Auto-refresh location (with consent), connectivity indicator
    - One-tap presets (Campus 25/6/15)
  - **Admin**
    - Bus health view (online/offline, last ping, driver)
    - Simple analytics snapshot (peak times, average load tier)
  - **Notifications (optional)**
    - Subscribe to destination (“Campus 25 bus within 1 km”)
    - In-app toasts; push later

### Phase 3 — Data, automation, scalability

- **Backend**
  - Historical storage and analytics jobs (daily rollups per route/time)
  - Predictive arrival estimates (simple ML or heuristics)
  - Seat counters integration (future hardware/QR boarding)
  - Incident/SOS endpoint + escalation workflow
  - Rate-based throttling per driver, anomaly detection (telemetry jumps)
  - Multi-tenant prep if needed (env/config separation)

- **Frontend**
  - **Student**
    - ETA per bus, arrival countdown
    - Saved preferences (preferred campus/routes)
    - Accessibility improvements (color-blind friendly tiers)
  - **Driver**
    - Route templates and shift schedules
    - Offline queueing when network drops
  - **Admin**
    - Heatmaps, demand curves, capacity planning dashboard
    - Export CSV, scheduled reports
  - **Notifications**
    - Smart alerts (“3 min arrival”), incident broadcasts
    - Quiet hours and granular user controls

### Data model (baseline)

- **Bus**
  - id, regNo, routeName, capacity, active
- **BusStatus**
  - busId, destination (enum), seatTier (enum: EMPTY/FEW/FULL), updatedAt
- **BusLocation**
  - busId, lat, lng, speed, heading, updatedAt
- **User**
  - id, email, role (STUDENT/DRIVER/ADMIN), driverBusId?
- **AuditLog**
  - id, actorId, action, entityType, entityId, timestamp, metadata

### API summary (baseline, Node option)

- `GET /buses` → list with status+latest location
- `GET /buses/:id`
- `POST /buses/:id/location` (driver)
- `POST /buses/:id/status` (driver)
- `GET /live` (SSE/WS)
- `POST /admin/buses` CRUD (admin)
- `POST /admin/drivers/assign` (admin)
- `POST /auth/login` (driver/admin), `GET /auth/me`

### Tech notes

- **Maps**: Leaflet.js + OpenStreetMap for cost; Google Maps if required
- **Realtime**: Firebase RTDB/Firestore listeners, or Node WS/SSE
- **Hosting**: Vercel/Netlify (frontend), Render/Fly.io/Cloud Run (backend), Mongo Atlas/Firebase for data
- **Security**: HTTPS, JWT/Firebase Auth, per-role rules, input validation
- **Telemetry**: error tracking (Sentry), logs + metrics

If you want, I can set up the repo scaffolding now (backend first, with either Firebase or Node+Mongo).